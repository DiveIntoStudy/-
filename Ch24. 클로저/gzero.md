- 클로저는 난해하기로 유명한 자바스크립트 개념 중 하나다
- 클로저는 자바스크립트 고유 개념이 아니어서, ECMAScript 사양에 없다.
- MDN에서의 클로저 정의 : 클로저는 **함수**와 그 **함수가 선언된 렉시컬 환경**과의 조합이다.
  - 함수가 선언된 렉시컬 환경 = 상위 스코프를 의미하는 실행 컨텍스트의 렉시컬 환경

## 24.1 렉시컬 스코프

- 렉시컬 스코프(정적 스코프)는 자바스크립트 엔진이 함수를 **어디**에 정의했는지에 따라 상위 스코프를 결정하는 것을 말한다.
- 렉시컬 환경의 ‘외부 렉시컬 환경에 대한 참조’에 저장할 참조값. 즉, **상위 스코프에 대한 참조**는 함수 정의가 평가되는 시점에 **함수가 정의된 환경(위치)에 의해 결정**된다.

## 24.2 함수 객체의 내부 슬롯 [[Environment]]

- 함수는 자신의 내부 슬롯 [[Environmnet]]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다.
- 함수 객체의 내부 슬롯 [[Environment]]에 저장된 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 바로 상위 스코프다. 또한 자신이 호출되었을 때 생성될 함수 렉시컬 환경의 ‘외부 렉시컬 환경에 대한 참조’에 저장될 참조값이다. 함수 객체는 내부 슬롯 [[Environment]]에 저장한 렉시컬 환경의 참조, 즉 상위 스코프를 자신이 존재하는 한 기억한다.

## 24.3 클로저와 렉시컬 환경

```jsx
const x = 1;

function outer() {
	const x = 10;
	const inner = function () { console.log(x) }
	return inner;
}

// outer 함수를 호출하면 중첩 함수 inner를 반환한다.
// 그리고 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 팝되어 제거된다.
function innerFunc = outer();
innerFunc(); // 10
```

- `outer 함수`를 호출하면 `outer 함수`는 `inner 함수`를 반환하고 생명주기를 마감한다. 즉, `outer 함수`의 실행이 종료되면 `outer 함수`의 실행 컨텍스트는 실행 컨텍스트 스택에서 삭제된다. 그래서 `outer 함수`의 지역 변수는 더이상 유효하지 않게 되어, `innerFunc()`함수를 실행했을때 지역 변수 x 에 접근할 방법이 없어 보인다.
- 하지만! `innerFunc()`의 실행 결과는`10`이다. 이게 가능한 이유는 클로저때문이다. 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 한다.
  - outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거되지만 outer 함수의 렉시컬 환경까지 소멸하는 것은 아니다.
  - outer 함수의 렉시컬 환경은 inner 함수의 [[Environment]] 내부 슬롯에 의해 참조되고 있고, inner 함수는 전역 변수 innerfunc에 의해 참조되고 있으므로 가비지 컬렉션의 대상이 되지 않기 때문이다. 가비지 컬렉터는 누군가가 참조하고 있는 메모리 공간을 함부로 해제하지 않는다.
- 자바스크립트의 모든 함수는 상위 스코프를 기억하므로 이론적으로 모든 함수는 클로저다. 하지만 일반적으로 모든 함수를 클로저라고 하지 않는다.
  - 상위 스코프의 어떤 식별자도 참조하지 않는 함수는 클로저가 아니다.
  - 클로저인 중첩 함수가 외부 함수보다 일찍 소멸하면 클로저의 본질에 부합하지 않는다.
- 클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다.

## 24.4 클로저의 활용

- 클로저는 상태(state)를 안전하게 변경하고 유지하기 위해 사용한다. 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.

## 24.5 캡슐화와 정보 은닉

- 캡슐화
  - 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다.
- 정보 은닉
  - 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는 이를 정보 은닉이라 한다.
  - 외부에 공개할 필요가 없는 구현의 일부를 외부에 공개되지 않도록 감추어 적절치 못한 접근으로부터 객체의 상태가 변경되는 것을 방지해 정보를 보호하고, 객체 간의 상호 의존성, 즉 결합도를 낮추는 효과가 있다.
- 자바스크립트는 정보 은닉을 완전하게 지원하지 않는다. 인스턴스 메서드를 사용한다면 자유 변수를 통해 private을 흉내 낼 수는 있지만 프로토타입 메서드를 사용하면 이마저도 불가능해진다. ES6의 Symbol 또는 WeakMap을 사용하여 private한 프로퍼티를 흉내 내기도 했으나 근본적인 해결책이 되지 않는다.

---

**❗️우리가 사용하는 상태 라이브러리(zustand, redux 등)은 클로저 개념을 활용해서 만든 걸까?**

> 네, 상태 관리 라이브러리들(예: **Zustand**, **Redux**, **MobX** 등)은 **클로저(closure)** 개념을 활용해서 상태(state)를 안전하고 효율적으로 관리합니다. 하지만 각 라이브러리가 클로저를 사용하는 방식과 정도는 다릅니다. 자세히 살펴볼게요.
>
> ---
>
> ### 1. **클로저란?**
>
> 클로저는 자바스크립트에서 함수가 자신이 선언된 **렉시컬 스코프(lexical scope)**를 "기억"하여, 해당 스코프에 있는 변수에 접근할 수 있는 개념입니다.
>
> ```jsx
> function createCounter() {
>   let count = 0; // 클로저로 캡처된 변수
>
>   return function () {
>     count++;
>     return count;
>   };
> }
>
> const counter = createCounter();
> console.log(counter()); // 1
> console.log(counter()); // 2
> ```
>
> 여기서 `count`는 외부 함수의 변수지만, 내부 함수에서 계속 접근 가능합니다. 상태 관리 라이브러리들도 이러한 원리를 사용합니다.
>
> ---
>
> ### 2. **Zustand와 클로저**
>
> **Zustand**는 클로저를 적극적으로 활용하는 상태 관리 라이브러리입니다.
>
> - `create()` 함수를 사용하여 상태 스토어를 생성합니다. 이 과정에서 클로저를 통해 상태를 안전하게 캡슐화합니다.
> - 상태와 액션은 클로저 내부에 저장되며, 스토어를 통해서만 접근 가능합니다.
>
> ```jsx
> import create from "zustand";
>
> const useStore = create((set) => ({
>   count: 0,
>   increase: () => set((state) => ({ count: state.count + 1 })),
> }));
>
> // 클로저로 캡슐화된 상태
> const { count, increase } = useStore.getState();
> increase();
> console.log(count); // 1
> ```
>
> 여기서 `set`과 `state`는 클로저로 묶여 있어 외부에서는 직접 접근이 불가능하며, 안전한 상태 관리를 보장합니다.
>
> ---
>
> ### 3. **Redux와 클로저**
>
> **Redux**는 클로저를 사용하지만, 클로저만으로 상태를 관리하지는 않습니다. Redux는 **함수형 프로그래밍** 패턴(특히 **리듀서 함수**)을 활용하여 상태 변경을 제어합니다.
>
> - Redux의 `createStore()`는 내부적으로 상태와 리듀서를 클로저로 캡슐화하여 외부에서 직접 상태를 조작하지 못하도록 합니다.
> - 대신, 액션을 디스패치하여 상태를 변경하는 방식으로 클로저의 원리를 보완합니다.
>
> ```jsx
> javascript
> 코드 복사
> import { createStore } from 'redux';
>
> function counterReducer(state = { count: 0 }, action) {
>   switch (action.type) {
>     case 'INCREMENT':
>       return { count: state.count + 1 };
>     default:
>       return state;
>   }
> }
>
> const store = createStore(counterReducer);
>
> // 클로저로 내부 상태 보호
> console.log(store.getState()); // { count: 0 }
> store.dispatch({ type: 'INCREMENT' });
> console.log(store.getState()); // { count: 1 }
>
> ```
>
> 여기서 `createStore`는 클로저를 사용하여 상태를 관리하고, `getState`와 `dispatch` 메서드만 노출합니다.
>
> ---
>
> ### 4. **다른 상태 라이브러리들**
>
> - **MobX**는 상태를 클로저로 묶기보다는 **리액티브(reaction)** 패턴을 사용하여 상태 변경을 추적하고 반응합니다.
> - **Recoil**은 클로저를 활용하여 상태(atom)를 관리하지만, 동시에 React의 Context와 결합하여 상태를 컴포넌트 계층에서 공유합니다.
>
> ---
>
> ### 요약
>
> - 상태 관리 라이브러리는 클로저를 활용하여 상태를 외부에서 보호하고, 안전하게 관리합니다.
> - **Zustand**는 클로저를 매우 직관적으로 사용하며, **Redux**는 클로저와 함수형 프로그래밍을 결합하여 상태를 관리합니다.
> - 각 라이브러리는 클로저 외에도 다양한 패턴(리액티브 패턴, 프로바이더-컨슈머 패턴 등)을 결합하여 더 풍부한 기능을 제공합니다.
