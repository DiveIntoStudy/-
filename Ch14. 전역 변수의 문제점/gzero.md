## 1. 변수의 생명 주기

- 변수의 생명 주기는 메모리 공간이 확보된 시점부터 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점까지다. 할당된 메모리 공간은 더 이상 참조되지 않을 때 가비지 콜렉터에 의해 해제되어 가용 메모리 풀에 반환된다.

### 1-1. 지역 변수의 생명 주기

- 함수 내부에 선언한 변수(지역 변수)는 함수가 호출된 직후에 함수 몸체의 코드가 한 줄씩 순차적으로 실행되기 이전에 자바스크립트 엔진에 의해 먼저 실행된다.
- 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.

### 1-2. 전역 변수의 생명 주기

- 전역 코드는 명시적인 호출 없이 실행된다. 지역 변수처럼 특별한 진입적이 없고 코드가 로드되자마자 곧바로 해석되고 실행된다.
- 전역 코드에는 반환문을 사용할 수 없으므로 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료한다.
- var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다.
- 전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치한다는 것이다.
- 전역 객체
  - 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 제일 먼저 생성되는 특수한 객체다
  - 클라이언트 사이드 환경(브라우저)에서는 window, 서버 사이드 환경(Node.js)에서는 global 객체를 의미한다.
  - 전역 객체는 표준 빌드인 객체(Object, String, Number, Function, Array …), 환경에 따른 호스트 객체(클라이언트 Web API, Node.js 호스트 API), var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다
- 전역 객체 window는 웹페이지를 닫기 전까지 유효하다. 즉, var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다

## 2. 전역 변수의 문제점

- 암묵적 결합
  - 모든 코드가 전역 변수를 참조하고 변경할 수 있다.
- 긴 생명 주기
  - 메모리 리소스를 오랜 기간 소비한다
  - 긴 생명주기로 인해 전역 변수 이름이 중복될 가능성이 있다
- 스코프 체인 상에서 종점에 존재
  - 전역 변수는 스코프 체인 상 종점에 존재해서, 변수를 검색할 때 가장 마지막에 검색된다. → 전역 변수의 검색 속도가 가장 느리다
- 네임스페이스 오염
  - 자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다는 것이다. 그래서 예상치 못한 결과를 가져올 수 있다

## 3. 전역 변수의 사용을 억제하는 방법

- 전역 변수를 반드시 사용해야할 이유가 없다면 지역 변수를 사용해야 한다.
- 변수의 스코프는 좁을수록 좋다

### 1. 즉시 실행 함수

- 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.
- 전역 변수를 생성하지 않으므로 라이브러리 등에 자주 사용된다

### 2. 네임스페이스 객체

- 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법
- 네임스페이스를 분리해서 식별자 충동을 방지하는 효과는 있으나 네임스페이스 객체 자체가 전역 변수에 할당되므로 그다지 유용해 보이지는 않는다.

### 3. 모듈 패턴

- 클래스를 모방해서 관련있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다.
- 모듈 패턴은 클로저 기반으로 동작한다
- 모듈 패턴을 사용하면 전역 변수 억제, 캡슐화까지 구현할 수 있다.
  - 캡슐화란?
    - 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다

### 4. ES6 모듈

- ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다. 모듈 내에서 선언한 var은 전역변수가 아니다.
- script 태그에서 type=”module” 를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다.

```jsx
<script type="module" src="lib.mjs" />
```

- ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하기 때문에, Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다

❗️ES6부터 트리쉐이킹이 가능한 이유는 ES6가 독자적인 모듈 스코프를 제공하기 때문이다.

> - `ES6 모듈(ECMAScript 2015 모듈)`이 트리 쉐이킹(Tree Shaking)이 가능한 이유 중 하나는 **파일 자체의 독자적인 모듈 스코프**를 제공하고, 모듈의 **정적인 구조** 덕분입니다. 이는 ES6 모듈이 CommonJS와 같은 기존 모듈 시스템과 다른 중요한 특성입니다.
>
> ### ES6 모듈이 트리 쉐이킹이 가능한 이유
>
> 1.  **정적 구조 (Static Structure)**:
>     ES6 모듈은 **정적 분석**이 가능합니다. 즉, `import`와 `export`는 **컴파일 타임**에 미리 분석할 수 있는 구조로, 동적으로 모듈을 불러오거나 변형할 수 없습니다. 이 덕분에 트리 쉐이킹을 수행할 때, 어떤 모듈이 사용되는지 미리 분석할 수 있어 **사용되지 않는 코드(dead code)를 제거**할 수 있습니다.
>         예를 들어:
>
>         ```jsx
>         javascript
>         코드 복사
>         // module.js
>         export const usedFunction = () => { console.log('This is used!'); }
>         export const unusedFunction = () => { console.log('This is not used!'); }
>
>         // main.js
>         import { usedFunction } from './module';
>         usedFunction();
>
>         ```
>
>         여기서 `unusedFunction`은 `main.js`에서 사용되지 않기 때문에, 빌드 도구(예: Webpack, Rollup 등)는 이를 제거할 수 있습니다.
> 2.  **파일 단위의 독립된 모듈 스코프**:
>     ES6 모듈은 **모듈당 고유한 스코프**를 가지며, 전역 스코프를 오염시키지 않습니다. 이로 인해 **모듈 간 의존성**을 명확하게 분석할 수 있습니다. 또한, 각 모듈은 **서로 독립적**이므로, 사용되지 않는 모듈을 안전하게 제거할 수 있습니다.
> 3.  **명시적 `import`와 `export`**:
>     ES6 모듈에서 모듈을 가져오거나 내보내는 것은 `import`와 `export` 키워드를 통해 **명시적으로** 이루어집니다. 이로 인해 트리 쉐이킹 도구는 코드를 분석하면서 어떤 모듈이 사용되고, 사용되지 않는지를 쉽게 파악할 수 있습니다. - **`export`**: 모듈에서 내보낼 함수나 변수를 명시합니다. - **`import`**: 외부 모듈에서 필요한 항목만 선택적으로 가져올 수 있습니다.
> 4.  **동적 로딩을 허용하지 않음**:
>     CommonJS와 같은 모듈 시스템에서는 `require()`를 **런타임**에 동적으로 호출할 수 있지만, ES6 모듈에서는 **정적인 `import`/`export`만 허용**됩니다. 이로 인해 빌드 시점에서 사용되지 않는 코드를 정확하게 파악하고 제거할 수 있습니다.
>
> ### ES6 모듈과 CommonJS의 차이
>
> **CommonJS**(Node.js에서 사용하는 모듈 시스템)는 런타임에 동적으로 모듈을 가져올 수 있어, 빌드 도구가 미리 어떤 모듈이 사용되는지 예측하기 어렵습니다. `require()`를 런타임에서 호출하는 구조이기 때문에, CommonJS 모듈 시스템에서는 트리 쉐이킹이 효과적으로 적용되지 않습니다.
>
> ```jsx
> javascript
> 코드 복사
> // CommonJS 예시
> const usedFunction = require('./module').usedFunction;
> usedFunction();
>
> ```
>
> 위의 코드에서 `require()`는 런타임에 호출되므로 빌드 도구는 `module` 내의 어떤 함수가 실제로 사용되는지 사전에 알기 어렵습니다.
>
> ### 결론
>
> ES6 모듈이 **트리 쉐이킹**이 가능한 이유는:
>
> - **정적 구조** 덕분에 모듈이 사용되는지 여부를 빌드 시점에서 미리 알 수 있기 때문입니다.
> - **독립적인 모듈 스코프**를 제공하고, 모듈 간 의존성을 명확하게 관리할 수 있어 사용되지 않는 코드의 안전한 제거가 가능합니다.
>
> 따라서 ES6 모듈은 최적화 도구가 코드를 쉽게 분석하고, 필요 없는 부분을 제거하는 데 유리한 구조를 제공합니다.
