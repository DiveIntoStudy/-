# CH26 ES6 함수의 추가 기능

## 26.1 함수의 구분

```javascript
var foo = function () {
  return 1;
};

// 일반적인 함수로 호출
foo(); // -> 1

// 생성자 함수로서 호출
new foo(); // foo {}

// 메서드로서 호출
var obj = { foo: foo };
obj.foo(); // 1
```

| ES6 함수의 구분 | constructor | prototype | super | arguments |
| --------------- | :---------: | :-------: | :---: | :-------: |
| 일반 함수       |      O      |     O     |   X   |     O     |
| 메서드          |      X      |     X     |   O   |     O     |
| 화살표 함수     |      X      |     X     |   X   |     X     |

## 26.2 메서드

&nbsp;ES6 사양에서 메서드는 **메서드 축약표현으로 정의된 함수**만을 의미

- 인스턴스 생성 불가(non-constructor)로 생성자 함수로서 호출할 수 없음
- 자신을 바인딩한 객체를 가리키는 내부 슬롯 `[[HomeObject]]`를 갖기 때문에 `super` 키워드를 사용할 수 있음

## 26.3 화살표 함수

&nbsp;콜백 함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 유용

### 26.3.1 화살표 함수 정의

> 너무 기본적인 것들이라 생략

#### 함수 정의

#### 매개변수 선언

#### 함수 몸체 정의

### 26.3.2 화살표 함수와 일반 함수의 차이

1. 화살표 함수는 인스턴스를 생성할 수 없는 `non-constructor`다.

   화살표 함수는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.

2. 중복된 매개변수 이름을 선언할 수 없다.

   strict mode가 아닐 때, 일반 함수는 중복된 매개변수 이름을 선언해도 에러가 발생하지 않는다.

3. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 가지지 않는다.

   스코프 체인 상에서 가장 가까운 상위 함수 중에서 화살표 함수가 아닌 함수의 this, arguments, super, new.target을 참조한다.

### 26.3.3 this

&nbsp;화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다. 이를 lexical this라고 한다. 이는 마치 렉시컬 스코프와 같이 **화살표 함수의 this가 함수의 정의된 위치에 의해 결정**된다는 것을 의미한다.

### 26.3.4 super

&nbsp;화살표 함수는 함수 자체의 super 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 super를 참조하면 this와 마찬가지로 상위 스코프의 super를 참조한다.

### 26.3.5 arguments

&nbsp;화살표 함수는 함수 자체의 arguments 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 arguments를 참조하면 상위 스코프의 arguments를 참조한다.

## 26.4 Rest 파라미터

### 26.4.1 기본 문법

&nbsp;Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.

### 26.4.2 Rest 파라미터와 arguments 객체

- argumenst 객체는 유사 배열 객체로, 배열 메서드를 사용하려면 배열로 변환해야함
- rest 파라미터를 사용하면 배열로 직접 전달받을 수 있음
- 화살표 함수로 가변 인자 함수를 구현할 때는 반드시 Rest 파라미터를 사용해야함

## 26.5 매개변수 기본값

&nbsp;매개변수에 인수를 전달하지 않은 경우와 undefined를 전달한 경우에 사용되는 기본 값
